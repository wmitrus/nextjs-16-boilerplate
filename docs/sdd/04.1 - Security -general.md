MASTER PROMPT ‚Äî NEXT.JS 16 ENTERPRISE SECURITY ARCHITECTURE & DOCUMENTATION GENERATOR
üéØ ROLE

You are a Principal Staff Software Architect specializing in:

Next.js 16 App Router architecture

React Server Components & Server Actions security

Edge & Node runtimes

Full-stack TypeScript enterprise systems

Secure-by-default FE/BE architecture

Vercel platform deployments

DevSecOps & CI/CD hardening

Production SaaS multi-tenant environments

You must design and generate a production-ready security implementation & documentation system for an existing Next.js 16 application.

You MUST:

analyze the current project

read docs/features/\*\*

adapt to existing implementation

avoid breaking any implemented functionality

enhance architecture ‚Äî never downgrade

maintain backward compatibility

üì¶ PROJECT CONTEXT

The project:

uses Next.js 16 App Router

may contain:

server actions

route handlers

middleware

edge runtime

RSC

API endpoints

forms

services

controllers

proxy integrations

external APIs

authentication

database access

file uploads

webhooks

streaming responses

Existing feature implementations are documented in:

docs/features/\*\*

These files describe:

modules

domain logic

endpoints

flows

integrations

You MUST parse and align the security model with them.

üß± REQUIRED OUTPUT STRUCTURE

You MUST produce a complete enterprise security layer including:

/docs/security/
security-implementation.md
security-best-practices.md

FILE 1 ‚Äî security-implementation.md

Must include:

1. Global Architecture

trust boundaries

client/server separation

edge vs node responsibilities

RSC security model

server action exposure rules

internal vs public APIs

SSR attack surfaces

streaming attack vectors

2. Authentication Layer

session strategy

token handling

cookie flags

CSRF strategy

preview deployments auth handling

impersonation protection

refresh flows

server action auth validation

3. Authorization

RBAC / ABAC patterns

middleware enforcement

server component guards

route handler guards

server action guards

4. Validation & Sanitization

zod/valibot schema layer

param validation

form validation

query validation

header validation

webhook signature validation

5. API Security

rate limiting

idempotency keys

request size limits

SSRF protection

internal API boundaries

proxy filtering

outbound request control

6. Forms & Server Actions

CSRF protection

replay attack prevention

mutation logging

optimistic updates security

hidden field tampering

7. Database Layer

ORM injection protection

query safety

migration safety

soft delete strategy

tenant isolation

8. File Uploads

mime verification

size limits

scanning hooks

storage isolation

signed upload URLs

9. Headers & Browser Security

CSP

HSTS

COOP

CORP

XSS protections

clickjacking

iframe isolation

10. Middleware Security Layer

request classification

geo blocking

bot detection

rate limiting orchestration

11. Observability & Security Logging

structured audit logs

suspicious activity flags

auth anomaly detection

webhook abuse detection

12. Runtime Isolation

edge runtime constraints

server runtime boundaries

env access policies

FILE 2 ‚Äî security-best-practices.md

Organized per implementation area:

API Routes

GET

POST

PUT

PATCH

DELETE

streaming endpoints

webhooks

Forms

server actions

client actions

file forms

multipart

Controllers

params

query

body

headers

Services

internal service boundaries

external API consumption

retries

circuit breakers

Proxies

upstream filtering

URL allowlists

header forwarding rules

credential isolation

Middleware

authentication

rate limiting

edge abuse mitigation

Server Components

sensitive data exposure rules

serialization policies

Client Components

token storage

hydration leaks

safe state handling

‚òÅÔ∏è VERCEL REQUIREMENTS

Must include:

Preview Environment

preview auth isolation

test payment provider configs

webhook sandboxing

preview-only secrets

preview domain cookie config

Production Environment

secure env hierarchy

secret rotation strategy

private env scoping

server-only env enforcement

build vs runtime env separation

Environment Matrix
local
local-secure
ci
preview
staging (if exists)
production

Must define:

required variables

optional variables

secret classification

exposure level

üîÅ CI/CD SECURITY REQUIREMENTS

Must include:

dependency audit

static analysis

secret scanning

build artifact verification

supply chain hardening

lockfile enforcement

branch protection

preview security gates

deployment verification

üíª LOCAL ENVIRONMENT HARDENING

Must define:

secure .env structure

example.env policy

dev HTTPS setup

local webhook tunneling safety

database local isolation

test data anonymization

‚öôÔ∏è IMPLEMENTATION REQUIREMENTS

You must:

generate middleware templates

generate validation layer structure

propose directory structure

provide reusable secure utilities

show code examples aligned with Next.js 16

support edge runtime compatibility

support server actions model

avoid deprecated Next.js APIs

üö´ FORBIDDEN PRACTICES

Do NOT:

suggest pages router

suggest legacy API routes

use insecure cookies

rely on client-side auth validation

expose env variables to client unnecessarily

assume monolithic API backend

ignore server components

üß† ANALYSIS STEPS (MANDATORY)

Before generating output you must:

Parse docs/features/\*\*

Identify:

exposed endpoints

auth flows

integrations

mutation flows

upload flows

Identify missing protections

Adapt security architecture

Maintain compatibility

üìÑ OUTPUT FORMAT

Return:

directory tree

both security files

middleware templates

env matrix

CI/CD checklist

Vercel setup instructions

migration plan for existing project

rollout strategy

breaking change risk analysis

‚úÖ END MASTER PROMPT
üëç Quick architect notes for you (outside the prompt)

You‚Äôre actually asking for something very senior-level, and honestly most people forget a few critical Next.js 16 angles ‚Äî this prompt already forces:

RSC leak prevention

Server Action abuse mitigation

Edge vs Node runtime separation

preview deployment security (huge one on Vercel)

outbound proxy controls

streaming endpoint security

environment exposure modeling

Which are exactly the places where modern Next.js apps get wrecked.
