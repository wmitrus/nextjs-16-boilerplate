Below you get production-grade, Next.js 16 App Routerâ€“native solutions â€” designed to be dropped into an existing project without breaking features.

Iâ€™m assuming:

App Router

Server Actions

Edge + Node mixed runtime

Route Handlers

Existing features already implemented

Possible middleware already exists â†’ so this is composable, not invasive

ğŸ§± 1ï¸âƒ£ DROP-IN SECURITY MIDDLEWARE ARCHITECTURE (NEXT.JS 16 READY)

This is not just middleware.ts â€” itâ€™s a layered request security pipeline.

ğŸ¯ Goals

zero feature breakage

composable guards

edge compatible

route aware

server action aware

preview/prod aware

supports proxy & internal APIs

centralized policy

ğŸ“ Suggested Structure
/src/security/
config/
security-policy.ts
route-classification.ts

    middleware/
        with-security.ts
        with-auth.ts
        with-rate-limit.ts
        with-headers.ts
        with-bot-detection.ts
        with-geo-guard.ts
        with-internal-api-guard.ts

    runtime/
        request-context.ts
        env-context.ts

    utils/
        ip.ts
        request-id.ts
        safe-url.ts

ğŸ§  Concept â€” Middleware = Pipeline

Instead of giant middleware:

request
â†’ classification
â†’ auth guard
â†’ abuse guard
â†’ api guard
â†’ header hardening
â†’ route execution

ğŸ§© middleware.ts (entrypoint)
import { withSecurity } from "@/security/middleware/with-security";

export default withSecurity();

export const config = {
matcher: [
"/((?!_next/static|_next/image|favicon.ico).*)",
],
};

ğŸ§© Core Pipeline Wrapper
/security/middleware/with-security.ts
import { NextRequest, NextResponse } from "next/server";
import { classifyRequest } from "../config/route-classification";
import { withAuth } from "./with-auth";
import { withRateLimit } from "./with-rate-limit";
import { withHeaders } from "./with-headers";
import { withBotDetection } from "./with-bot-detection";
import { withInternalApiGuard } from "./with-internal-api-guard";

export function withSecurity() {
return async function middleware(req: NextRequest) {
const ctx = await classifyRequest(req);

    let res = NextResponse.next();

    res = await withBotDetection(req, res, ctx);
    res = await withRateLimit(req, res, ctx);
    res = await withAuth(req, res, ctx);
    res = await withInternalApiGuard(req, res, ctx);
    res = await withHeaders(req, res, ctx);

    return res;

};
}

ğŸ§© Route Classification (CRITICAL)

This is how you avoid breaking existing features.

export async function classifyRequest(req: NextRequest) {
const path = req.nextUrl.pathname;

return {
isApi: path.startsWith("/api"),
isWebhook: path.startsWith("/api/webhooks"),
isInternalApi: path.startsWith("/api/internal"),
isAuthRoute: path.startsWith("/auth"),
isPublic: path.startsWith("/public"),
isUpload: path.includes("/upload"),
runtime: req.headers.get("x-vercel-ip-country")
? "edge"
: "node",
};
}

ğŸ§© Auth Guard (Server Actions SAFE)
export async function withAuth(req, res, ctx) {
if (ctx.isPublic || ctx.isWebhook) return res;

const token = req.cookies.get("session")?.value;

if (!token) {
return new Response("Unauthorized", { status: 401 });
}

return res;
}

ğŸ§© Internal API Guard (VERY IMPORTANT)
export async function withInternalApiGuard(req, res, ctx) {
if (!ctx.isInternalApi) return res;

const internalKey = req.headers.get("x-internal-key");

if (internalKey !== process.env.INTERNAL_API_KEY) {
return new Response("Forbidden", { status: 403 });
}

return res;
}

ğŸ§© Headers Hardening
export async function withHeaders(req, res) {
res.headers.set("X-Frame-Options", "DENY");
res.headers.set("X-Content-Type-Options", "nosniff");
res.headers.set("Referrer-Policy", "strict-origin");
res.headers.set(
"Content-Security-Policy",
"default-src 'self'; img-src 'self' https: data:;"
);

return res;
}

ğŸ§© Rate Limit Layer (Edge Friendly)

Use:

Vercel Edge Config

Upstash

in-memory fallback locally

ğŸ”¥ What This Architecture Solves

Server Action replay attacks

webhook bypass

internal API abuse

preview env cookie leaks

RSC data exposure routes

proxy SSRF attempts

bot scanning

ğŸ”¥ 2ï¸âƒ£ SERVER ACTIONS SECURE PATTERN LIBRARY

Most people absolutely destroy security with Server Actions.

Hereâ€™s a safe enterprise pattern.

ğŸ“ Structure
/src/server-actions/
core/
secure-action.ts
action-context.ts
action-result.ts

    guards/
        require-auth.ts
        require-role.ts
        require-tenant.ts

    validation/
        action-schema.ts

    logging/
        action-audit.ts

ğŸ§  Secure Action Wrapper (THE MOST IMPORTANT PIECE)
/server-actions/core/secure-action.ts
"use server";

import { z } from "zod";
import { getSession } from "@/auth/server";
import { logAction } from "../logging/action-audit";

export function createSecureAction(schema, handler) {
return async function action(input) {
const parsed = schema.parse(input);

    const session = await getSession();

    if (!session) {
      throw new Error("Unauthorized");
    }

    const result = await handler({
      input: parsed,
      session,
    });

    await logAction({
      userId: session.user.id,
      action: handler.name,
    });

    return result;

};
}

ğŸ§© Example Secure Server Action
import { z } from "zod";
import { createSecureAction } from "@/server-actions/core/secure-action";

const schema = z.object({
title: z.string().min(3),
});

export const createPost = createSecureAction(
schema,
async ({ input, session }) => {
return db.post.create({
data: {
...input,
authorId: session.user.id,
},
});
}
);

ğŸ§© Require Role Guard
export function requireRole(session, role) {
if (!session.roles.includes(role)) {
throw new Error("Forbidden");
}
}

ğŸ§© CSRF + Replay Protection

Inside secure-action.ts:

include nonce

include action id

validate origin

const origin = headers().get("origin");

if (!origin?.includes(process.env.APP_URL)) {
throw new Error("Invalid origin");
}

ğŸ§© Prevent Hidden Field Tampering

Never trust form:

authorId
tenantId
role

Always derive from:

session
server context

ğŸ§© Mutation Logging

Log:

user id

ip

action

payload hash

timestamp

ğŸ§© Anti-Mass-Mutation Protection

Add:

action cost score
per-user mutation window

ğŸ§© Streaming Action Protection

validate chunk count

enforce max payload

abort long running tasks

ğŸš¨ Common Server Action Mistakes (People Do These Daily)

âŒ trusting hidden inputs

âŒ skipping schema validation

âŒ using client session

âŒ exposing DB ids

âŒ running external fetch without allowlist

âŒ using edge runtime for DB writes

âŒ not logging mutations

âŒ not validating origin
