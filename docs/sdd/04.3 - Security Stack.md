ENTERPRISE NEXT.JS 16 SECURITY STACK
ğŸ¯ Architecture Goals

single security boundary for all execution contexts

secure-by-default server actions

RSC data leakage prevention

outbound SSRF firewall

unified authorization model

environment exposure control

tenant isolation

runtime-aware enforcement (edge vs node)

preview-safe deployments

zero trust internal APIs

ğŸ§± CORE STRUCTURE
/src/security/
core/
security-context.ts
security-runtime.ts
auth-boundary.ts
authorization-engine.ts
tenant-engine.ts

    middleware/
        with-security.ts
        guards/

    actions/
        secure-action.ts
        action-replay.ts
        action-policy.ts

    api/
        secure-route.ts
        webhook-guard.ts

    rsc/
        safe-server-component.ts
        data-sanitizer.ts

    outbound/
        secure-fetch.ts
        proxy-firewall.ts

    streaming/
        stream-guard.ts

    headers/
        csp-generator.ts
        header-policy.ts

    env/
        env-access.ts
        env-policy.ts

    observability/
        audit-log.ts
        anomaly-detector.ts

ğŸ” 1ï¸âƒ£ UNIFIED SECURITY CONTEXT (THE FOUNDATION)

All execution layers must share the same context.

security-context.ts
export type SecurityContext = {
user?: {
id: string;
roles: string[];
tenantId?: string;
};
ip: string;
origin?: string;
runtime: "edge" | "node";
requestId: string;
env: "local" | "ci" | "preview" | "production";
};

security-runtime.ts

Build context from:

middleware

headers

cookies

vercel env

ip

runtime detection

ğŸ” 2ï¸âƒ£ AUTH BOUNDARY (EVERYTHING PASSES THROUGH THIS)
middleware
server action
route handler
RSC loader

auth-boundary.ts
export async function buildAuthContext(req) {
const session = await getSession(req);

return {
user: session?.user,
};
}

No component reads session directly.

EVER.

ğŸ” 3ï¸âƒ£ AUTHORIZATION ENGINE

Supports:

RBAC

ABAC

tenant scoping

feature-based policies

export function authorize(ctx, policy) {
if (!ctx.user) throw new Error("Unauthorized");

if (policy.role && !ctx.user.roles.includes(policy.role)) {
throw new Error("Forbidden");
}
}

ğŸ¢ 4ï¸âƒ£ TENANT ISOLATION ENGINE

Enforces:

DB query scoping

mutation scoping

file storage prefixing

cache partitioning

export function enforceTenant(ctx, tenantId) {
if (ctx.user?.tenantId !== tenantId) {
throw new Error("Tenant violation");
}
}

ğŸ”¥ 5ï¸âƒ£ ENTERPRISE SERVER ACTION SYSTEM
secure-action.ts

Features:

schema validation

origin validation

replay tokens

mutation logging

tenant enforcement

outbound firewall

export function createSecureAction(schema, handler) {
return async function action(input) {
const ctx = await buildSecurityContext();

    validateOrigin(ctx);
    validateReplayToken();

    const parsed = schema.parse(input);

    authorize(ctx, {});

    return handler({ ctx, input: parsed });

};
}

ğŸ” Replay Protection
nonce
timestamp
hash
per-user action window

ğŸŒ 6ï¸âƒ£ SECURE ROUTE HANDLER SYSTEM
secure-route.ts
export function secureRoute(handler, policy) {
return async function route(req) {
const ctx = await buildSecurityContext(req);

    authorize(ctx, policy);

    validateRequest(req);

    return handler({ req, ctx });

};
}

ğŸ§  7ï¸âƒ£ RSC SAFE DATA LAYER

Never return:

tokens

internal ids

internal flags

raw ORM models

data-sanitizer.ts
export function sanitizeData(data) {
return structuredClone(data, {
transfer: [],
});
}

Use DTOs always.

ğŸŒ 8ï¸âƒ£ OUTBOUND REQUEST FIREWALL (SSRF PROTECTION)
secure-fetch.ts
const ALLOWED = [
"api.stripe.com",
"api.openai.com",
];

export async function secureFetch(url, opts) {
const host = new URL(url).hostname;

if (!ALLOWED.includes(host)) {
throw new Error("Outbound blocked");
}

return fetch(url, opts);
}

ğŸ” 9ï¸âƒ£ STREAMING RESPONSE GUARD

max chunk count

timeout

content inspection

rate control

export function guardStream(stream) {
let chunks = 0;

return new TransformStream({
transform(chunk, controller) {
chunks++;
if (chunks > 500) throw new Error("Stream abuse");
controller.enqueue(chunk);
},
});
}

ğŸ§± ğŸ”Ÿ AUTOMATIC CSP GENERATOR

Scans:

routes

external scripts

image domains

analytics

CDN usage

Outputs dynamic CSP header per route.

ğŸ” 1ï¸âƒ£1ï¸âƒ£ ENVIRONMENT ACCESS FIREWALL
env-access.ts
export function getServerEnv(key) {
if (typeof window !== "undefined") {
throw new Error("Client env access");
}

return process.env[key];
}

ğŸ” 1ï¸âƒ£2ï¸âƒ£ OBSERVABILITY + ANOMALY DETECTION

Audit everything:

server actions

auth failures

tenant violations

replay attempts

SSRF attempts

internal API access

â˜ï¸ VERCEL ENTERPRISE SECURITY SETUP
Preview

isolated cookies

preview-only secrets

webhook sandbox mode

no production DB

preview auth banner

Production

server-only env vars

edge restricted secrets

private env groups

secret rotation policy

ğŸ” CI/CD SECURITY PIPELINE

Required jobs:

dependency audit

secret scan

license scan

SAST

RSC exposure scan

CSP drift detection

lockfile enforcement

environment diff validation

ğŸ’» LOCAL HARDENING

HTTPS dev cert

local webhook signature validation

anonymized seed data

isolated local tenant

mock external services

ğŸ§  What This Stack Protects Against

Server Action replay attacks

RSC sensitive data leaks

internal API abuse

SSRF via proxy routes

preview deployment token leaks

cross-tenant mutations

outbound credential exfiltration

streaming abuse

hidden form tampering

unsafe env exposure

edge runtime privilege leaks
